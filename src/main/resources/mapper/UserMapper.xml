<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--名称空间和映射器类必须一致，方法名称和id必须一致-->
<mapper namespace="com.example.demo.dao.UserDao">







    <!--基础-->

    <!--resultType必须存在，和resultMap不能共存-->
    <select id="queryUserById" resultType="User">
        select *,user.name AS userName from tb_user as `user` where id = #{id}
    </select>


    <!--resultType必须存在-->
    <!--返回值为list，resultType为其泛型-->
    <select id="queryAll" resultType="User">
        select *,user.name AS userName from tb_user as `user`;
    </select>


    <!-- 不需要 resultType -->
    <!-- useGeneratedKeys:返回自动生成的主键-->
    <!-- keyProperty:将useGeneratedKeys返回的值设置到该属性-->
    <!-- keyColumn:如果表中主键不是第一列，设置目标列名-->
    <insert id="insertUser" useGeneratedKeys="true" keyProperty="id" keyColumn="id">

        INSERT INTO tb_user (
        id,
        user_name,
        password,
        name,
        age,
        sex,
        birthday,
        created,
        updated
        )
        VALUES
        (
        NULL,
        <!-- 这里用#{字段名}，mybatis会自动根据字段名，去User参数中找字段值，设置到Sql中 -->
        #{userName},
        #{password},
        #{name},
        #{age},
        #{sex},
        #{birthday},
        NOW(),
        NOW()
        );
    </insert>

    <!-- 不需要 resultType -->
    <update id="updateUser">
        UPDATE tb_user
        SET
        user_name = #{userName},
        password = #{password},
        name = #{name},
        age = #{age},
        sex = #{sex},
        birthday = #{birthday},
        updated = NOW()
        WHERE
        id = #{id};
	</update>

    <!-- 不需要 resultType -->
    <delete id="deleteUserById">
		DELETE FROM tb_user WHERE id = #{id}
	</delete>









    <!--映射-->

    <select id="queryUserByUsernameAndPassword" resultMap="userResultMap">
        <!--在不能识别参数名称的情况下，通过在接口使用@Param注解，使得此处能够利用键名来获取value-->
        SELECT
        <include refid="userColumns"/>
        FROM tb_user WHERE user_name = #{userName} AND password = #{password}
    </select>

    <!--解决列名和对象属性名不一致的问题-->
    <!--autoMapping默认为true，如果设置为false，则必须每个属性都要用result/id映射，即使名称相同-->
    <resultMap id="userResultMap" type="User" autoMapping="true">

        <!--指定id能够提高映射效率-->
        <id property="id" column="id"/>

        <!--如果在yml文件中开启了驼峰映射，就不需要用result再手动映射-->
        <!--<result property="userName" column="user_name"/>-->

    </resultMap>


    <sql id="userColumns">
        id,user_name,password,name,age,sex,birthday,created,updated,note
    </sql>









    <!--动态标签-->

    <select id="queryMaleUserByName" resultMap="userResultMap">
        select
        <include refid="userColumns"/>
        from tb_user
        where sex = '1'
        <if test="name != null and name.trim() != ''">
            and name like CONCAT('%',#{name},'%');
        </if>
    </select>

    <select id="queryAllUserAndSort" resultType="User">
        SELECT
        <include refid="userColumns"/>
        FROM tb_user
        <choose>
            <when test="orderType == 0">
              ORDER BY age ASC
            </when>
            <when test="orderType == 1">
              ORDER BY age DESC
            </when>
            <otherwise>
              ORDER BY id ASC
            </otherwise>
        </choose>
    </select>

    <select id="queryUserByNameAndAge" resultType="User">
        SELECT <include refid="userColumns"/>
        FROM tb_user
        <where> <!--where标签去掉多余的AND,没有条件去掉where-->
            <if test="name != null and name.trim() != ''">
                AND name like CONCAT("%",#{name},"%")
            </if>
            <if test="age != null">
                <!--小于号要做变换，-->
                AND age &lt; #{age}
            </if>
        </where>
    </select>


    <!--增删改操作，如果dao的返回值为int，成功就返回影响的行数-->
    <update id="update">
        UPDATE tb_user
        <!--set标签去除多余的","-->
        <set>
            <if test="name != null and name.trim() != ''">
                name = #{name},
            </if>
            <if test="age != null">
                age = #{age},
            </if>
        </set>
        <where>
            <if test="id != null">
                id = #{id}
            </if>
        </where>
    </update>

    <select id="queryUserByIds" resultType="User">
        SELECT <include refid="userColumns"/>
        FROM tb_user
        <!--where标签中为null，去掉where-->
        <where>
            <!--test中可以使用大于等于，而不需要转义-->
            <if test="ids != null and ids.size() > 0">
                <foreach collection="ids" open="id in (" close=")" separator="," item="id">
                    #{id}
                </foreach>
            </if>
        </where>
    </select>













    <!--一对多查询-->
    <!--如果联合查询中，多个列同名，比如order、user表中都有id，mybatis会拿第一个id做映射，
        如果第一个id是User的id，同样也会映射到Order的id上，这里要注意-->
    <select id="queryOrderAndNumberByOrderNumber" resultMap="orderUserResult">
        SELECT o.*,u.*
        FROM tb_order o
        LEFT JOIN tb_user u ON o.user_id = u.id
        WHERE o.order_number = #{orderNumber}
    </select>

    <!--autoMapping保证名称一样的列和属性能够自动映射-->
    <resultMap id="orderUserResult" type="Order" autoMapping="true">
        <id column="id" property="id"/>
        <!--autoMapping保证名称一样的列和属性能够自动映射-->
        <!--属性中有对象类型，用association做映射-->
        <association property="user" javaType="User" autoMapping="true">
            <!--这里如果映射列id，那么会选择第一个id列，也就是order的id，是错误的-->
            <id property="id" column="user_id"/>
        </association>
    </resultMap>

</mapper>

